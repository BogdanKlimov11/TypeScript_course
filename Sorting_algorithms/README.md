<h1>Алгоритмы сортировки</h1>

---

<!-- Оглавление -->
<h2>Оглавление</h2>

<nav>
    <ul>
        <li><a href="#определение">Определение</a></li>
        <li><a href="#оценка-сложности">Оценка сложности</a></li>
        <li><a href="#виды-сложностей">Виды сложностей</a></li>
        <li><a href="#раздел-1">Сортировка пузырьком (Bubble sort)</a></li>
        <li><a href="#раздел-2">Сортировка перемешиванием (Cocktail sort)</a></li>
        <li><a href="#раздел-3">Сортировка вставками (Insertion sort)</a></li>
        <li><a href="#раздел-4">Гномья сортировка (Gnome sort)</a></li>
        <li><a href="#раздел-5">Сортировка слиянием (Merge sort)</a></li>
        <li><a href="#раздел-6">Сортировка с помощью двоичного дерева (Tree sort)</a></li>
        <li><a href="#раздел-7">Сортировка Timsort (Timsort)</a></li>
        <li><a href="#раздел-8">Сортировка выбором (Selection sort)</a></li>
        <li><a href="#раздел-9">Сортировка расчёской (Comb sort)</a></li>
        <li><a href="#раздел-10">Сортировка Шелла (Shell sort)</a></li>
        <li><a href="#раздел-11">Сортировка пирамидой (Heap sort)</a></li>
        <li><a href="#раздел-12">Плавная сортировка (Smooth sort)</a></li>
        <li><a href="#раздел-13">Быстрая сортировка (Quick sort)</a></li>
        <li><a href="#раздел-14">Интроспективная сортировка (Intro sort)</a></li>
        <li><a href="#раздел-15">Блочная сортировка (Bucket sort)</a></li>
        <li><a href="#раздел-16">Поразрядная сортировка (Radix sort)</a></li>
        <li><a href="#раздел-17">Сортировка подсчётом (Counting sort)</a></li>
    </ul>
</nav>

---

<h2 id="определение">Определение</h2>

**Сортировка** - это процесс упорядочивания элементов в некоторой последовательности по определенному критерию 
или правилу. Этот процесс широко используется в компьютерных науках и информатике для упорядочивания данных, 
что позволяет более эффективно и удобно работать с этими данными.

В общем случае, сортировка применяется к спискам, массивам или последовательностям элементов, и она может 
быть выполнена по различным критериям, например:

1. По возрастанию или убыванию значения элементов.

2. По алфавитному порядку (для строк).

3. По размеру элементов (для чисел или других данных).

4. По какому-то специфическому ключу или признаку (например, фамилия, возраст, дата и т. д.).

---

<h2 id="оценка-сложности">Оценка сложности</h2>

Определение сложности алгоритма включает в себя анализ количества ресурсов (таких как время и память), которые 
требуются для выполнения алгоритма в зависимости от размера входных данных. Вот основные способы определения 
сложности алгоритма:

1. **Временная сложность:** Это оценка количества операций, которые выполняет алгоритм в зависимости от размера
входных данных. Временная сложность может быть выражена в терминах лучшего, худшего или среднего случая.
Обычно она измеряется в "большом О" нотации, где n - размер входных данных. Оценка временной сложности позволяет
понять, как быстро алгоритм будет работать с увеличением размера входных данных.

2. **Пространственная сложность:** Это оценка количества памяти, которое требуется для выполнения алгоритма в
зависимости от размера входных данных. Пространственная сложность также может быть выражена в "большом О"
нотации, где n - размер входных данных. Оценка пространственной сложности позволяет понять, сколько памяти
будет использовано алгоритмом при обработке данных.

4. **Лучший, худший и средний случаи:** Некоторые алгоритмы могут иметь различную сложность в разных случаях.
Лучший случай представляет собой наилучший сценарий выполнения алгоритма, худший случай - наихудший сценарий,
а средний случай - средний сценарий, обычно применяется к случайно распределенным данным.

5. **Асимптотический анализ:** Это метод анализа сложности, который сосредотачивается на поведении алгоритма
при стремлении размера входных данных к бесконечности. В основе асимптотического анализа лежит "большая О"
нотация, которая определяет верхнюю границу роста времени выполнения или потребления памяти алгоритма.

Определение сложности алгоритма помогает выбирать наиболее подходящий алгоритм для конкретной задачи и предсказывать 
его поведение при работе с различными размерами входных данных.

---

<h2 id="виды-сложностей">Виды сложностей</h2>

<table>
    <tr>
        <th>Обозначение</th>
        <th>Название</th>
    </tr>
    <tr>
        <td>$O(1)$</td>
        <td>Константная сложность</td>
    </tr>
    <tr>
        <td>$O(\log n)$</td>
        <td>Логарифмическая сложность</td>
    </tr>
    <tr>
        <td>$O(n)$</td>
        <td>Линейная сложность</td>
    </tr>
    <tr>
        <td>$O(n \log n)$</td>
        <td>Квази-линейная сложность (линейно-логарифмическая)</td>
    </tr>
    <tr>
        <td>$O(n^a), a \in \mathbb N, a \geq 2$</td>
        <td>Степенная сложность</td>
    </tr>
    <tr>
        <td>$O(a^n), a \in \mathbb N, a \geq 2$</td>
        <td>Показательная сложность (экспоненциальная)</td>
    </tr>
    <tr>
        <td>$O(n!)$</td>
        <td>Факториальная сложность</td>
    </tr>
</table>

<img src="https://github.com/BogdanKlimov11/Python_course/assets/136115919/f9145fe6-f24d-47d6-894a-d185c46ac234" alt="Algorithm complexity" width="60%" height="auto">

---

<!-- Разделы -->
<h2 id="раздел-1">Сортировка пузырьком (Bubble sort)</h2>

Алгоритм сортировки пузырьком является одним из простейших и наиболее интуитивно понятных алгоритмов сортировки. 
Он получил название "пузырьком" из-за того, что большие элементы "всплывают" к концу списка, как пузырьки воды.

<h3>Описание шагов алгоритма:</h3>

1. **Проходы по массиву:** Алгоритм состоит из нескольких проходов по всем элементам массива. На каждом проходе 
  сравниваются два соседних элемента и, если они находятся в неправильном порядке, они меняются местами.

2. **Сравнение и перестановка:** На каждом проходе мы начинаем с начала массива и сравниваем каждую пару соседних 
  элементов. Если текущий элемент больше следующего, мы их меняем местами.

3. **Повторение:** После завершения одного прохода, наибольший элемент перемещается в конец массива. Мы повторяем 
  этот процесс до тех пор, пока в массиве не будет произведено ни одной перестановки.

4. **Завершение:** Когда на последнем проходе не было ни одной перестановки, массив считается отсортированным, и 
  алгоритм завершает свою работу.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, когда массив отсортирован в обратном порядке или почти отсортирован.

- **Средняя случай:** $O(n^2)$, так как алгоритм требует полного прохода по массиву для каждого элемента.

- **Лучшая случай:** $O(n)$, когда массив уже отсортирован, но при этом алгоритм по-прежнему выполняет полный проход по 
  массиву.

<h3>Устойчивость:</h3>

Сортировка пузырьком является устойчивой, что означает, что она сохраняет порядок равных элементов. Таким образом, 
если у нас есть два одинаковых элемента, и один из них стоит перед другим в исходном массиве, после сортировки они 
также будут находиться в том же порядке.

---

<h2 id="раздел-2">Сортировка перемешиванием (Cocktail sort)</h2>

Алгоритм сортировки перемешиванием - это вариант сортировки пузырьком, который работает в обоих направлениях, в то 
время как сортировка пузырьком работает только в одном направлении.

<h3>Описание шагов алгоритма:</h3>

1. **Прямой проход (слева направо):** Начните с начала массива и последовательно сравнивайте пары соседних элементов. Если 
  текущий элемент больше следующего, поменяйте их местами. Перемещайтесь слева направо по массиву.

2. **Обратный проход (справа налево):** После завершения прямого прохода перейдите в обратном направлении, начиная с последнего 
  элемента и сравнивая пары элементов. Если текущий элемент меньше предыдущего, поменяйте их местами. Перемещайтесь справа 
  налево по массиву.

3. **Повторение:** Повторяйте прямой и обратный проходы до тех пор, пока не будет сделано ни одной перестановки на одном из 
  проходов.

4. **Завершение:** Когда на прямом и обратном проходах не было сделано ни одной перестановки, массив считается отсортированным.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, когда массив отсортирован в обратном порядке или почти отсортирован.

- **Средняя случай:** $O(n^2)$, так как алгоритм требует полного прохода по массиву для каждого элемента.

- **Лучшая случай:** $O(n)$, когда массив уже отсортирован, так как в этом случае не будет ни одной перестановки.

<h3>Устойчивость:</h3>

Сортировка перемешиванием является устойчивой. Это означает, что она сохраняет порядок равных элементов.

---

<h2 id="раздел-3">Сортировка вставками (Insertion sort)</h2>

Алгоритм сортировки вставками работает путем последовательного вставления каждого элемента массива в уже 
отсортированную часть массива.

<h3>Описание шагов алгоритма:</h3>

1. **Проход по массиву:** Начните с элемента, находящегося на первой позиции массива.

2. **Вставка в отсортированную часть:** Сравните текущий элемент с элементами, находящимися перед ним в отсортированной
   части массива. Если текущий элемент меньше элемента, с которым он сравнивается, переместите его налево до тех
   пор, пока он не окажется на правильной позиции в отсортированной части.

3. **Повторение:** Продолжайте этот процесс для каждого элемента в массиве, начиная со второго.

4. **Завершение:** Когда все элементы будут вставлены на свои места, массив будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, когда массив отсортирован в обратном порядке или почти отсортирован, и каждый элемент 
  должен быть вставлен на правильное место в отсортированной части массива.

- **Средняя случай:** $O(n^2)$, так как алгоритм требует полного прохода по массиву для каждого элемента.

- **Лучшая случай:** $O(n)$, когда массив уже отсортирован, так как в этом случае ни одна перестановка не требуется, и 
  каждый элемент просто сравнивается с предыдущим элементом.

<h3>Устойчивость:</h3>

Сортировка вставками является устойчивой. Это означает, что она сохраняет порядок равных элементов, то есть если у 
нас есть два одинаковых элемента, и один из них стоит перед другим в исходном массиве, после сортировки они также 
будут находиться в том же порядке.

---

<h2 id="раздел-4">Гномья сортировка (Gnome sort)</h2>

Алгоритм гномьей сортировки (Gnome Sort) является простым алгоритмом сортировки, который работает путем последовательного 
перемещения элементов массива в нужную позицию.

<h3>Описание шагов алгоритма:</h3>

1. **Инициализация:** Начните с индекса i = 0.

2. **Сравнение с предыдущим элементом:** Сравните текущий элемент массива с предыдущим элементом. Если текущий элемент больше или 
  равен предыдущему, переместите индекс на одну позицию вправо (i++).

3. Перемещение назад при необходимости:** Если текущий элемент меньше предыдущего, поменяйте их местами и уменьшите индекс на 
  одну позицию влево (i--). Повторяйте этот шаг до тех пор, пока текущий элемент не будет больше или равен предыдущему, или 
  пока не достигнете начала массива.

4. **Переход к следующему элементу:** Перейдите к следующему элементу массива и повторите шаги 2-3 для него.

5. **Завершение:** Когда все элементы будут обработаны, массив будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, когда массив отсортирован в обратном порядке или почти отсортирован, и каждый элемент требуется 
  переместить в начало массива.

- **Средняя случай:** $O(n^2)$, так как алгоритм требует полного прохода по массиву для каждого элемента.

- **Лучшая случай:** $O(n)$, когда массив уже отсортирован, так как в этом случае не будет ни одной перестановки.

<h3>Устойчивость:</h3>

Гномья сортировка является устойчивой. Это означает, что она сохраняет порядок равных элементов.

---

<h2 id="раздел-5">Сортировка слиянием (Merge sort)</h2>

Алгоритм сортировки слиянием работает по принципу "разделяй и властвуй". Он разбивает исходный массив на две половины, 
рекурсивно сортирует каждую половину, а затем сливает их в один отсортированный массив.

<h3>Описание шагов алгоритма:</h3>

1. **Разделение массива:** Исходный массив делится пополам.

2. **Рекурсивная сортировка:** Каждая половина массива сортируется рекурсивно с помощью алгоритма слияния.

3. **Слияние отсортированных половин:** Отсортированные половины массива объединяются в один отсортированный массив. Это 
  происходит путем поочередного выбора наименьшего элемента из двух половин и перемещения его в конец нового массива.

4. **Базовый случай:** Рекурсия завершается, когда размер каждого подмассива становится равным 1.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n \log n)$, так как всякий раз массив делится пополам и рекурсивно сортируется, а затем объединяется
  обратно в один отсортированный массив.

- **Средняя случай:** $О(n \log n)$, так как алгоритм делит массив на две части и выполняет сортировку для
  каждой половины.

- **Лучшая случай:** $О(n \log n)$, так как даже если массив уже отсортирован, алгоритм по-прежнему делит его на две половины
  и рекурсивно сортирует их.

<h3>Устойчивость:</h3>

Сортировка слиянием является устойчивой. Это означает, что она сохраняет относительный порядок элементов с одинаковыми значениями.

---

<h2 id="раздел-6">Сортировка с помощью двоичного дерева (Tree sort)</h2>

Алгоритм сортировки с помощью двоичного дерева заключается во вставке элементов массива в двоичное дерево 
поиска и последующем обходе дерева в порядке возрастания.

<h3>Описание шагов алгоритма:</h3>

1.  **Вставка элементов в дерево:** Начните с создания пустого двоичного дерева поиска. Затем поочередно вставляйте каждый элемент 
  массива в дерево.

2. **Обход дерева в порядке возрастания:** Выполните обход дерева в порядке возрастания (in-order traversal). Это позволит получить 
  отсортированную последовательность элементов.

3. **Завершение:** Когда все элементы будут вставлены и обойдены в дереве, массив будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, когда массив представляет собой отсортированный или почти отсортированный список, и дерево принимает 
  форму одноуровневого списка.

- **Средняя случай:** $O(n \log n)$, так как каждый элемент вставляется в дерево за $O(\log n)$ времени, а затем обход дерева занимает 
  $O(n)$ времени.

- **Лучшая случай:** $O(n \log n)$, когда дерево имеет сбалансированную структуру.

<h3>Устойчивость:</h3>

Сортировка с помощью двоичного дерева поиска является устойчивой, если для вставки элементов используется метод, который 
сохраняет относительный порядок элементов с одинаковыми ключами. Однако в общем случае это не гарантируется, так как порядок 
элементов с одинаковыми ключами зависит от конкретной реализации вставки в дерево.

---

<h2 id="раздел-7">Сортировка Timsort (Timsort)</h2>

Timsort - это адаптивный алгоритм сортировки, который сочетает в себе сортировку вставками и сортировку слиянием, разработанный для 
использования в Python.

<h3>Описание шагов алгоритма:</h3>

1. **Разбиение на подмассивы:** Исходный массив разбивается на подмассивы определенного размера.

2. **Сортировка вставками:** Каждый подмассив сортируется с использованием сортировки вставками.

3. **Слияние подмассивов:** Отсортированные подмассивы сливаются в один отсортированный массив с помощью сортировки слиянием.

4. **Дополнительные шаги:** Алгоритм Timsort также включает дополнительные шаги для обработки особых случаев, таких как обнаружение и 
  обработка упорядоченных и обратно упорядоченных подмассивов.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n \log n)$, где $n$ - размер входного массива. Это достигается за счет использования сортировки вставками для
  малых подмассивов и сортировки слиянием для их последующего слияния.

- **Средняя случай:** $O(n \log n)$. В среднем алгоритм работает так же, как и другие алгоритмы сортировки слиянием, так как он
  использует их в основе.

- **Лучшая случай:** $O(n)$, когда массив уже частично упорядочен. Timsort эффективно обрабатывает частично упорядоченные массивы
  благодаря сортировке вставками.

<h3>Устойчивость:</h3>

Сортировка Timsort является устойчивой, что означает, что она сохраняет порядок равных элементов.

---

<h2 id="раздел-8">Сортировка выбором (Selection sort)</h2>

Алгоритм сортировки выбором работает путем многократного выбора минимального (или максимального) элемента из оставшейся части 
массива и обмена его с первым (или последним) элементом в текущей неотсортированной части.

<h3>Описание шагов алгоритма:</h3>

1. **Начало сортировки:** Начните с текущего индекса, который указывает на начало массива.

2. **Поиск минимального элемента:** Найдите минимальный элемент в оставшейся части массива, начиная с текущего индекса.

3. **Обмен с началом:** Обменяйте минимальный элемент с элементом на текущем индексе.

4. **Переход к следующему индексу:** Увеличьте текущий индекс на 1 и повторите процесс с шага 2 для оставшейся части массива.

5. **Завершение:** Когда все элементы будут проверены и обработаны, массив будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, где n - количество элементов в массиве. Это происходит, когда для каждого элемента массива требуется
  полный проход для поиска минимального элемента.

- **Средняя случай:** $O(n^2)$. В среднем алгоритм также требует полного прохода для каждого элемента.

- **Лучшая случай:** $O(n^2)$, когда массив уже отсортирован. Даже в этом случае алгоритм продолжит свою работу, полностью проходя по 
  всему массиву для каждого элемента.

<h3>Устойчивость:</h3>

Сортировка выбором не является устойчивой. Это означает, что она не сохраняет относительный порядок равных элементов. Например, если 
в массиве есть два одинаковых элемента, алгоритм может поменять их местами, что приведет к изменению их исходного порядка.

---

<h2 id="раздел-9">Сортировка расчёской (Comb sort)</h2>

Алгоритм сортировки расчёской является модификацией алгоритма сортировки пузырьком. Он работает путем сравнения 
элементов, находящихся на определенном расстоянии друг от друга, и обмена их местами в случае необходимости. 

<h3>Описание шагов алгоритма:</h3>

1. **Инициализация:** Начните с определения начального значения шага (gap), которое обычно равно длине массива. Также
   определите флаг, показывающий, была ли сделана хотя бы одна перестановка на текущей итерации.

2. **Сравнение элементов:** Сравните элементы массива, находящиеся на расстоянии gap друг от друга. Если текущий элемент
   больше элемента, находящегося на расстоянии gap, поменяйте их местами.

3. **Уменьшение шага:** Уменьшите значение gap на фиксированный коэффициент (обычно на 1.3 или другое оптимальное значение).

4. **Проверка флага:** Если на текущей итерации была хотя бы одна перестановка, установите флаг и повторите шаги 2-3. Если
   перестановок не было, завершите сортировку.

5. **Завершение:** Когда значение gap станет равным 1, алгоритм завершит свою работу, и массив будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, хотя на практике алгоритм работает быстрее сортировки пузырьком из-за использования большего шага.

- **Средняя случай:** $O(n^2)$, так как алгоритм может потребовать несколько итераций для завершения сортировки.

- **Лучшая случай:** $O(n \log n)$, в лучшем случае алгоритм может достичь линейной сложности.

<h3>Устойчивость:</h3>

Сортировка расчёской не является устойчивой. Это означает, что она не гарантирует сохранение порядка равных элементов.

---

<h2 id="раздел-10">Сортировка Шелла (Shell sort)</h2>

Алгоритм сортировки Шелла является усовершенствованным вариантом сортировки вставками. Он работает путем сравнения элементов, 
находящихся на определенном расстоянии друг от друга, и обмена их местами в случае необходимости.

<h3>Описание шагов алгоритма:</h3>

1. **Выбор интервала:** Начните с определения последовательности интервалов, которые будут использоваться для сортировки. Интервалы 
  обычно выбираются убывающим образом согласно определенной последовательности (например, последовательности Шелла).

2. **Сортировка вставками с заданным интервалом:** Для каждого интервала выполните сортировку вставками, где каждый элемент 
  сдвигается на заданное расстояние.

3. **Уменьшение интервала:** Уменьшите интервал и повторите шаг 2. Продолжайте уменьшать интервал до тех пор, пока он не станет 
  равным 1.

4. **Сортировка вставками:** Завершите сортировку вставками с интервалом, равным 1.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, хотя на практике алгоритм имеет гораздо лучшую производительность за счет использования больших интервалов.

- **Средняя случай:** В зависимости от выбранной последовательности интервалов, средняя временная сложность может варьироваться от $O(n \log n)$
  до $O(n^2)$.

- **Лучшая случай:** В зависимости от выбранной последовательности интервалов, лучшая временная сложность может быть $O(n \log n)$ или лучше.

<h3>Устойчивость:</h3>

Сортировка Шелла не является устойчивой. Это означает, что она не гарантирует сохранение порядка равных элементов.

---

<h2 id="раздел-11">Сортировка пирамидой (Heap sort)</h2>

Алгоритм сортировки пирамидой основан на структуре данных "куча". Он состоит из двух основных этапов: построение кучи и сортировка 
массива с использованием кучи.

<h3>Описание шагов алгоритма:</h3>

1. **Построение кучи (Heapify):** Начните с построения максимальной кучи из исходного массива. Для этого переупорядочьте элементы
   массива так, чтобы для каждого узла выполнялось условие "родитель больше (или равен) обоих детей". Это обеспечит, что максимальный
   элемент окажется в корне кучи.

2. **Сортировка:** После того как куча построена, извлекайте максимальный элемент из корня кучи и помещайте его в конец массива. После
   каждого извлечения перестраивайте кучу таким образом, чтобы она снова стала максимальной. Повторяйте этот процесс до тех пор, пока
   весь массив не будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n \log n)$, где $n$ - количество элементов в массиве. В худшем случае каждый элемент массива должен пройти по всему 
  пути от листьев к корню кучи, что занимает $O(\log n)$ операций, и такое прохождение выполняется для каждого из n элементов.

- **Средняя случай:** $O(n \log n)$. В среднем случае время выполнения алгоритма также оценивается как $O(n \log n)$.

- **Лучшая случай:** $O(n \log n)$. В лучшем случае алгоритм требует того же количества операций, что и в худшем и среднем случае.

<h3>Устойчивость:</h3>

Сортировка пирамидой не является устойчивой. Это означает, что она не гарантирует сохранение относительного порядка равных элементов.

---

<h2 id="раздел-12">Плавная сортировка (Smooth sort)</h2>

Алгоритм плавной сортировки является усовершенствованным вариантом сортировки пирамидой и использует структуру данных "гладкая куча". Он 
хорошо подходит для сортировки почти упорядоченных массивов и обладает лучшими показателями производительности на частично упорядоченных 
данных.

<h3>Описание шагов алгоритма:</h3>

- **Построение "гладкой кучи":** Начните с построения "гладкой кучи" из исходного массива. Это делается путем добавления элементов по одному 
  и поддержания свойства "гладкой кучи".

- **Сортировка:** После того как "гладкая куча" построена, извлекайте минимальный элемент из корня кучи и помещайте его в конец массива. 
  После каждого извлечения перестраивайте "гладкую кучу" таким образом, чтобы она снова стала "гладкой". Повторяйте этот процесс до тех пор, 
  пока весь массив не будет отсортирован.

<h3>Временная сложность:</h3>

- **Худшая случай:** Оценка худшего времени выполнения алгоритма плавной сортировки не столь изучена, но обычно считается, что она имеет
  сложность $O(n \log n)$.

- **Средняя случай:** Оценка среднего времени выполнения также оценивается как $O(n \log n)$. Однако на частично упорядоченных данных алгоритм
  может показывать лучшие результаты.

- **Лучшая случай:** Оценка лучшего времени выполнения также оценивается как $O(n \log n)$.

<h3>Устойчивость:</h3>

Сортировка плавной сортировки является устойчивой, то есть она сохраняет порядок равных элементов. Это означает, что если два элемента равны 
по значению, их относительный порядок в отсортированном массиве будет таким же, как и в исходном.

---

<h2 id="раздел-13">Быстрая сортировка (Quick sort)</h2>

Алгоритм быстрой сортировки является одним из самых эффективных алгоритмов сортировки и основан на принципе "разделяй и властвуй".

<h3>Описание шагов алгоритма:</h3>

1. **Выбор опорного элемента:** Выбирается опорный элемент из массива. Это может быть любой элемент массива, но обычно выбирается средний элемент.

2. **Разделение массива:** Массив разделяется на две части так, чтобы все элементы, меньшие опорного, находились слева от него, а все элементы, 
  большие или равные опорному, находились справа от него.

3. **Рекурсивная сортировка подмассивов:** Применяется тот же алгоритм к двум подмассивам, образованным в результате разделения, до тех пор, пока 
  подмассивы не станут достаточно маленькими для сортировки вставками или другим стандартным методом.

4. **Объединение результатов:** После того как все подмассивы отсортированы, результаты объединяются в один отсортированный массив.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n^2)$, когда опорный элемент всегда является наименьшим или наибольшим элементом в подмассиве, что приводит к 
  несбалансированному разделению.

- **Средняя случай:** $O(n \log n)$, алгоритм имеет линейно-логарифмическую сложность в среднем случае, когда выбор опорного элемента приводит
- к сбалансированному разделению массива.

- **Лучшая случай:** $O(n \log n)$, когда массив делится на две равные части на каждом шаге рекурсии.

<h3>Устойчивость:</h3>

Быстрая сортировка, как правило, не является устойчивой. Это означает, что порядок элементов с одинаковыми ключами может измениться после сортировки.

---

<h2 id="раздел-14">Интроспективная сортировка (Intro sort)</h2>

Интроспективная сортировка - это гибридный алгоритм сортировки, который комбинирует в себе преимущества трех других алгоритмов сортировки: 
быстрой сортировки, сортировки кучей и сортировки вставками.

<h3>Описание шагов алгоритма:</h3>

1. **Использование быстрой сортировки:** Начните с быстрой сортировки массива. Быстрая сортировка эффективна для больших массивов, но может деградировать 
  до квадратичной сложности в худшем случае.

2. **Переключение на сортировку кучей:** Если глубина рекурсии превышает заданное значение (обычно $\log(n)$), алгоритм переключается на сортировку кучей.
   Это позволяет избежать худшего случая быстрой сортировки и гарантирует сложность $O(n \log n)$.

3. **Сортировка вставками для маленьких массивов:** Когда размер подмассива становится маленьким, переключаемся на сортировку вставками. Сортировка
   вставками эффективна для небольших массивов и имеет низкую константную сложность.

<h3>Временная сложность:</h3>

- **Худшая случай:** $O(n \log n)$. Это происходит из-за переключения на сортировку кучей, когда быстрая сортировка начинает проявлять неэффективность.

- **Средняя случай:** $O(n \log n)$. Интроспективная сортировка в среднем случае обеспечивает быстрый и стабильный результат, сочетая преимущества быстрой 
  сортировки, сортировки кучей и сортировки вставками.

- **Лучшая случай:** $O(n \log n)$. В лучшем случае алгоритм работает так же эффективно, как быстрая сортировка, без необходимости переключения на сортировку 
  кучей.

<h3>Устойчивость:</h3>

Интроспективная сортировка обычно не является устойчивой. Это значит, что порядок равных элементов может измениться после сортировки. Однако при необходимости 
можно модифицировать алгоритм таким образом, чтобы он сохранял устойчивость, например, использовать стабильные версии быстрой сортировки и сортировки вставками.

---

<h2 id="раздел-15">Блочная сортировка (Bucket sort)</h2>

Алгоритм блочной сортировки относится к разряду алгоритмов сортировки подсчетом. Он разбивает входной массив на несколько блоков (или "ведер") и 
затем сортирует каждый блок отдельно, обычно с использованием другого алгоритма сортировки, например, сортировки вставками или быстрой сортировки. 
После этого он объединяет отсортированные блоки в один отсортированный массив.

<h3>Описание шагов алгоритма:</h3>

1. **Разделение на блоки:** Алгоритм делит входной массив на несколько блоков (ведер), каждый из которых содержит элементы в определенном диапазоне.

2. **Сортировка блоков:** Каждый блок сортируется отдельно, обычно с использованием другого алгоритма сортировки, например, сортировки вставками или 
  быстрой сортировки.

3. **Объединение блоков:** После сортировки каждого блока алгоритм объединяет их в один отсортированный массив.

<h3>Временная сложность:</h3>

- **Худшая и средняя случаи:** $O(n^2)$, если каждый блок сортируется с использованием алгоритма сортировки вставками и количество блоков зависит
  от количества элементов в массиве. Однако, если количество блоков зависит от диапазона значений элементов, то сложность может быть лучше.

- **Лучший случай:** $O(n + k)$, где $n$ - количество элементов в массиве, а $k$ - количество блоков.

<h3>Устойчивость:</h3>

Устойчивость блочной сортировки зависит от устойчивости используемого алгоритма сортировки для сортировки блоков. Если используемый алгоритм 
сортировки является устойчивым, то и блочная сортировка также будет устойчивой.

---

<h2 id="раздел-16">Поразрядная сортировка (Radix sort)</h2>

Алгоритм поразрядной сортировки предназначен для сортировки целых чисел или строк по разрядам.

<h3>Описание шагов алгоритма:</h3>

1. **По разрядам:** Сортировка начинается с наименее значимого разряда и продолжается к более значимым разрядам.

2. **Сортировка подсчетом:** Для каждого разряда происходит сортировка подсчетом. Это означает, что мы считаем количество элементов,
   имеющих одинаковое значение в текущем разряде.

3. **Распределение элементов:** Затем элементы распределяются по корзинам (или "ведрам") на основе их значения в текущем разряде.

4. **Сборка отсортированных элементов:** После сортировки всех разрядов элементы собираются обратно в исходный массив.

Алгоритм может быть применен как для целых чисел, так и для строк. Для сортировки строк используется поразрядная сортировка по 
ASCII-кодам символов.

<h3>Временная сложность:</h3>

- **Худшая и средняя случаи:** $O(n*k)$, где $n$ - количество элементов в массиве, а $k$ - количество разрядов (обычно равно количеству
  цифр в максимальном числе).

- **Лучший случай:** $O(n*k)$, но так как $k$ обычно фиксирован, лучший случай также $O(n)$.

<h3>Устойчивость:</h3>

Поразрядная сортировка по умолчанию является устойчивой, если используется устойчивая сортировка подсчетом для каждого разряда. Это 
означает, что элементы с одинаковыми значениями в текущем разряде будут сохранять свой относительный порядок после сортировки.

---

<h2 id="раздел-17">Сортировка подсчётом (Counting sort)</h2>

Алгоритм сортировки подсчётом - это алгоритм сортировки, который сортирует элементы массива путем подсчета количества элементов с 
определенными значениями и их последующей упорядочиванием. Он хорошо работает для сортировки целых чисел или других элементов с 
ограниченным диапазоном значений.

<h3>Описание шагов алгоритма:</h3>

1. **Подсчет частоты:** Пройдемся по входному массиву и подсчитаем количество вхождений каждого уникального элемента.

2. **Накопление частоты:** На основе подсчитанных значений построим массив сумм частот. Этот массив будет указывать на индексы начала
   каждого уникального элемента в отсортированном массиве.

3. **Распределение элементов:** Пройдемся по входному массиву снова и распределим элементы в выходной массив с учетом их позиций в массиве
   сумм частот.

4. **Копирование в выходной массив:** Скопируем отсортированные элементы обратно в входной массив.

<h3>Временная сложность:</h3>

- **Худшая, средняя и лучшая случаи:** $O(n + k)$, где $n$ - количество элементов в массиве, а $k$ - размер диапазона значений элементов.
  Алгоритм эффективен, когда $k$ (размер диапазона) намного меньше $n$.

<h3>Устойчивость:</h3>

Сортировка подсчетом по умолчанию является устойчивой. Это означает, что элементы с одинаковыми значениями будут сохранять свой 
относительный порядок после сортировки.
